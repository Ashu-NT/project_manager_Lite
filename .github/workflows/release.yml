name: Build And Publish Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (for example: v2.1.1)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  windows-release:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve Release Metadata
        id: meta
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $tag = "${{ inputs.release_tag }}".Trim()
          } else {
            $tag = "${{ github.ref_name }}".Trim()
          }
          if ([string]::IsNullOrWhiteSpace($tag)) {
            throw "Release tag is required."
          }
          if (-not $tag.StartsWith("v")) {
            $tag = "v$tag"
          }
          $version = $tag.Substring(1)
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw "Could not parse version from tag '$tag'."
          }
          $installer = "Setup_ProjectManagerLite_$version.exe"
          $repo = "${{ github.repository }}"
          $downloadUrl = "https://github.com/$repo/releases/download/$tag/$installer"
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "installer=$installer" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "download_url=$downloadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "Resolved release: tag=$tag version=$version installer=$installer"

      - name: Resolve Project Paths
        id: paths
        shell: pwsh
        run: |
          $spec = Get-ChildItem -Path . -Recurse -File -Filter "main_qt.spec" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $spec) {
            Write-Host "Could not find main_qt.spec in workspace."
            Write-Host "Workspace root: $PWD"
            Get-ChildItem -Path . -Force
            throw "Spec file main_qt.spec not found."
          }

          $nsi = Get-ChildItem -Path . -Recurse -File -Filter "ProjectManagerLite.nsi" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nsi) {
            Write-Host "Could not find installer/ProjectManagerLite.nsi in workspace."
            Write-Host "Workspace root: $PWD"
            Get-ChildItem -Path . -Force
            throw "NSIS script ProjectManagerLite.nsi not found."
          }

          "spec_path=$($spec.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "nsi_path=$($nsi.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "project_root=$($spec.Directory.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "Resolved paths: spec=$($spec.FullName)"
          "Resolved paths: nsi=$($nsi.FullName)"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Python Dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install And Resolve NSIS
        id: nsis
        shell: pwsh
        run: |
          choco install nsis -y --no-progress
          $candidateRoots = @(
            "${env:ProgramFiles(x86)}\NSIS\makensis.exe",
            "${env:ProgramFiles}\NSIS\makensis.exe",
            "C:\ProgramData\chocolatey\bin\makensis.exe",
            "C:\ProgramData\chocolatey\lib\nsis\tools\makensis.exe",
            "C:\ProgramData\chocolatey\lib\nsis.install\tools\makensis.exe"
          )
          $nsisExe = $candidateRoots | Where-Object { Test-Path $_ } | Select-Object -First 1

          if (-not $nsisExe) {
            $cmd = Get-Command makensis.exe -ErrorAction SilentlyContinue
            if ($cmd) {
              $nsisExe = $cmd.Source
            }
          }

          if (-not $nsisExe) {
            $searchRoots = @(
              "C:\ProgramData\chocolatey\lib\nsis",
              "C:\ProgramData\chocolatey\lib\nsis.install",
              "${env:ProgramFiles(x86)}\NSIS",
              "${env:ProgramFiles}\NSIS"
            ) | Where-Object { Test-Path $_ }

            foreach ($root in $searchRoots) {
              $hit = Get-ChildItem $root -Recurse -File -Filter "makensis.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($hit) {
                $nsisExe = $hit.FullName
                break
              }
            }
          }

          if (-not $nsisExe) {
            Write-Host "NSIS path probes failed."
            Write-Host "ProgramFiles: $env:ProgramFiles"
            Write-Host "ProgramFiles(x86): ${env:ProgramFiles(x86)}"
            Get-ChildItem "C:\ProgramData\chocolatey\lib" -Directory -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName | ForEach-Object { Write-Host $_ }
            throw "NSIS installed but makensis.exe was not found."
          }

          $nsisDir = Split-Path -Parent $nsisExe
          $nsisDir | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "nsis_exe=$nsisExe" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          & $nsisExe /VERSION

      - name: Build PyInstaller Bundle
        shell: pwsh
        run: |
          python -m PyInstaller "${{ steps.paths.outputs.spec_path }}" --noconfirm --clean

      - name: Build NSIS Installer
        shell: pwsh
        run: |
          & "${{ steps.nsis.outputs.nsis_exe }}" /DAPP_VERSION=${{ steps.meta.outputs.version }} "${{ steps.paths.outputs.nsi_path }}"

      - name: Collect Installer Artifact
        shell: pwsh
        run: |
          $installerName = "${{ steps.meta.outputs.installer }}"
          $found = Get-ChildItem -Path . -Filter $installerName -Recurse | Select-Object -First 1
          if (-not $found) {
            throw "Installer '$installerName' not found after NSIS build."
          }
          New-Item -ItemType Directory -Path installer -Force | Out-Null
          $target = Join-Path "installer" $installerName
          Copy-Item $found.FullName -Destination $target -Force
          Write-Host "Installer ready at $target"

      - name: Generate Checksum And Manifest
        shell: pwsh
        run: |
          $installerPath = "installer\${{ steps.meta.outputs.installer }}"
          if (-not (Test-Path $installerPath)) {
            throw "Installer file missing at $installerPath"
          }

          $hash = (Get-FileHash -Path $installerPath -Algorithm SHA256).Hash.ToLowerInvariant()
          "$hash  ${{ steps.meta.outputs.installer }}" | Set-Content "installer\${{ steps.meta.outputs.installer }}.sha256"

          $manifest = @{
            channels = @{
              stable = @{
                version = "${{ steps.meta.outputs.version }}"
                url = "${{ steps.meta.outputs.download_url }}"
                notes = "Automated release from tag ${{ steps.meta.outputs.tag }}"
                sha256 = $hash
              }
              beta = @{
                version = "${{ steps.meta.outputs.version }}"
                url = "${{ steps.meta.outputs.download_url }}"
                notes = "Automated release from tag ${{ steps.meta.outputs.tag }}"
                sha256 = $hash
              }
            }
          }
          $manifest | ConvertTo-Json -Depth 5 | Set-Content "release-manifest.json"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ steps.meta.outputs.tag }}
          path: |
            installer/${{ steps.meta.outputs.installer }}
            installer/${{ steps.meta.outputs.installer }}.sha256
            release-manifest.json
          if-no-files-found: error

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.tag }}
          generate_release_notes: true
          prerelease: ${{ contains(steps.meta.outputs.tag, '-') }}
          files: |
            installer/${{ steps.meta.outputs.installer }}
            installer/${{ steps.meta.outputs.installer }}.sha256
            release-manifest.json
          fail_on_unmatched_files: true

      - name: Release Summary
        shell: pwsh
        run: |
          @"
          Release published for tag: ${{ steps.meta.outputs.tag }}
          Installer: ${{ steps.meta.outputs.installer }}
          Manifest asset URL (latest release):
          https://github.com/${{ github.repository }}/releases/latest/download/release-manifest.json
          "@ | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
