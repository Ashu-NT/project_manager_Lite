name: Build And Publish Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (for example: v2.1.1)"
        required: true
        type: string

permissions:
  contents: write

jobs:
  windows-release:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve Release Metadata
        id: meta
        shell: pwsh
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $tag = "${{ inputs.release_tag }}".Trim()
          } else {
            $tag = "${{ github.ref_name }}".Trim()
          }
          if ([string]::IsNullOrWhiteSpace($tag)) {
            throw "Release tag is required."
          }
          if ($tag -match "\s") {
            throw "Release tag cannot contain spaces. Use a tag like v2.1.1."
          }
          if ($tag -notmatch "^v?[0-9]+(\.[0-9]+){1,3}([\-+][0-9A-Za-z\.-]+)?$") {
            throw "Invalid release tag '$tag'. Expected v<major>.<minor>.<patch> (optionally with prerelease suffix)."
          }
          if (-not $tag.StartsWith("v")) {
            $tag = "v$tag"
          }
          $version = $tag.Substring(1)
          if ([string]::IsNullOrWhiteSpace($version)) {
            throw "Could not parse version from tag '$tag'."
          }
          $installer = "Setup_ProjectManagerLite_$version.exe"
          $repo = "${{ github.repository }}"
          $downloadUrl = "https://github.com/$repo/releases/download/$tag/$installer"
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "version=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "installer=$installer" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "download_url=$downloadUrl" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "Resolved release: tag=$tag version=$version installer=$installer"

      - name: Resolve Project Paths
        id: paths
        shell: pwsh
        run: |
          $spec = Get-ChildItem -Path . -Recurse -File -Filter "main_qt.spec" -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($spec) {
            "spec_path=$($spec.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            Write-Host "Resolved paths: spec=$($spec.FullName)"
          } else {
            "spec_path=" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
            Write-Host "No main_qt.spec found. Will use script-based PyInstaller build."
          }

          $entry = Get-ChildItem -Path . -Recurse -File -Filter "main_qt.py" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $entry) {
            Write-Host "Could not find main_qt.py in workspace."
            Write-Host "Workspace root: $PWD"
            Get-ChildItem -Path . -Force
            throw "Entry script main_qt.py not found."
          }

          $nsi = Get-ChildItem -Path . -Recurse -File -Filter "ProjectManagerLite.nsi" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $nsi) {
            Write-Host "Could not find installer/ProjectManagerLite.nsi in workspace."
            Write-Host "Workspace root: $PWD"
            Get-ChildItem -Path . -Force
            throw "NSIS script ProjectManagerLite.nsi not found."
          }

          "entry_path=$($entry.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "nsi_path=$($nsi.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "project_root=$($entry.Directory.FullName)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "Resolved paths: entry=$($entry.FullName)"
          "Resolved paths: nsi=$($nsi.FullName)"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Stamp Runtime App Version
        shell: pwsh
        run: |
          $projectRoot = "${{ steps.paths.outputs.project_root }}"
          if ([string]::IsNullOrWhiteSpace($projectRoot)) {
            throw "Project root path is missing; cannot stamp app version."
          }
          $versionFile = Join-Path $projectRoot "infra\app_version.txt"
          "${{ steps.meta.outputs.version }}" | Set-Content $versionFile -Encoding utf8
          Write-Host "Stamped runtime app version: $versionFile -> ${{ steps.meta.outputs.version }}"

      - name: Install Python Dependencies
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install And Resolve NSIS
        id: nsis
        shell: pwsh
        run: |
          choco install nsis -y --no-progress
          $candidateRoots = @(
            "${env:ProgramFiles(x86)}\NSIS\makensis.exe",
            "${env:ProgramFiles}\NSIS\makensis.exe",
            "C:\ProgramData\chocolatey\bin\makensis.exe",
            "C:\ProgramData\chocolatey\lib\nsis\tools\makensis.exe",
            "C:\ProgramData\chocolatey\lib\nsis.install\tools\makensis.exe"
          )
          $nsisExe = $candidateRoots | Where-Object { Test-Path $_ } | Select-Object -First 1

          if (-not $nsisExe) {
            $cmd = Get-Command makensis.exe -ErrorAction SilentlyContinue
            if ($cmd) {
              $nsisExe = $cmd.Source
            }
          }

          if (-not $nsisExe) {
            $searchRoots = @(
              "C:\ProgramData\chocolatey\lib\nsis",
              "C:\ProgramData\chocolatey\lib\nsis.install",
              "${env:ProgramFiles(x86)}\NSIS",
              "${env:ProgramFiles}\NSIS"
            ) | Where-Object { Test-Path $_ }

            foreach ($root in $searchRoots) {
              $hit = Get-ChildItem $root -Recurse -File -Filter "makensis.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($hit) {
                $nsisExe = $hit.FullName
                break
              }
            }
          }

          if (-not $nsisExe) {
            Write-Host "NSIS path probes failed."
            Write-Host "ProgramFiles: $env:ProgramFiles"
            Write-Host "ProgramFiles(x86): ${env:ProgramFiles(x86)}"
            Get-ChildItem "C:\ProgramData\chocolatey\lib" -Directory -ErrorAction SilentlyContinue | Select-Object -ExpandProperty FullName | ForEach-Object { Write-Host $_ }
            throw "NSIS installed but makensis.exe was not found."
          }

          $nsisDir = Split-Path -Parent $nsisExe
          $nsisDir | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          "nsis_exe=$nsisExe" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          & $nsisExe /VERSION

      - name: Build PyInstaller Bundle
        shell: pwsh
        run: |
          $specPath = "${{ steps.paths.outputs.spec_path }}".Trim()
          if (-not [string]::IsNullOrWhiteSpace($specPath)) {
            Write-Host "Using spec file build: $specPath"
            python -m PyInstaller "$specPath" --noconfirm --clean
            exit $LASTEXITCODE
          }

          $entryPath = "${{ steps.paths.outputs.entry_path }}"
          $projectRoot = "${{ steps.paths.outputs.project_root }}"
          if ([string]::IsNullOrWhiteSpace($entryPath) -or [string]::IsNullOrWhiteSpace($projectRoot)) {
            throw "Cannot run script-based build: entry path or project root missing."
          }

          $assets = "$projectRoot\assets;assets"
          $migration = "$projectRoot\migration;migration"
          $appVersion = "$projectRoot\infra\app_version.txt;infra"
          $icon = "$projectRoot\assets\icons\app.ico"

          Write-Host "Using script-based build: $entryPath"
          python -m PyInstaller `
            "$entryPath" `
            --noconfirm `
            --clean `
            --name "ProjectManagerLite" `
            --windowed `
            --icon "$icon" `
            --add-data "$assets" `
            --add-data "$migration" `
            --add-data "$appVersion" `
            --collect-submodules "infra" `
            --collect-submodules "core" `
            --collect-submodules "ui" `
            --hidden-import "logging.config"

      - name: Build NSIS Installer
        shell: pwsh
        run: |
          & "${{ steps.nsis.outputs.nsis_exe }}" "/DAPP_VERSION=${{ steps.meta.outputs.version }}" "${{ steps.paths.outputs.nsi_path }}"

      - name: Collect Installer Artifact
        shell: pwsh
        run: |
          $installerName = "${{ steps.meta.outputs.installer }}"
          $found = $null
          $preferred = @(
            (Join-Path "installer" $installerName),
            $installerName
          )
          foreach ($candidate in $preferred) {
            if (Test-Path $candidate) {
              $found = Get-Item $candidate
              break
            }
          }

          if (-not $found) {
            $found = Get-ChildItem -Path . -Filter $installerName -Recurse -File |
              Sort-Object LastWriteTimeUtc -Descending |
              Select-Object -First 1
          }
          if (-not $found) {
            throw "Installer '$installerName' not found after NSIS build."
          }
          New-Item -ItemType Directory -Path installer -Force | Out-Null
          $target = Join-Path "installer" $installerName
          $sourceFull = [System.IO.Path]::GetFullPath($found.FullName)
          $targetFull = [System.IO.Path]::GetFullPath($target)
          if ($sourceFull -ieq $targetFull) {
            Write-Host "Installer already in target location: $targetFull"
          } else {
            Copy-Item $found.FullName -Destination $target -Force
          }
          Write-Host "Installer ready at $target"

      - name: Generate Checksum And Manifest
        shell: pwsh
        run: |
          $installerPath = "installer\${{ steps.meta.outputs.installer }}"
          if (-not (Test-Path $installerPath)) {
            throw "Installer file missing at $installerPath"
          }

          $hash = (Get-FileHash -Path $installerPath -Algorithm SHA256).Hash.ToLowerInvariant()
          "$hash  ${{ steps.meta.outputs.installer }}" | Set-Content "installer\${{ steps.meta.outputs.installer }}.sha256"

          $manifest = @{
            channels = @{
              stable = @{
                version = "${{ steps.meta.outputs.version }}"
                url = "${{ steps.meta.outputs.download_url }}"
                notes = "Automated release from tag ${{ steps.meta.outputs.tag }}"
                sha256 = $hash
              }
              beta = @{
                version = "${{ steps.meta.outputs.version }}"
                url = "${{ steps.meta.outputs.download_url }}"
                notes = "Automated release from tag ${{ steps.meta.outputs.tag }}"
                sha256 = $hash
              }
            }
          }
          $manifest | ConvertTo-Json -Depth 5 | Set-Content "release-manifest.json"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ steps.meta.outputs.tag }}
          path: |
            installer/${{ steps.meta.outputs.installer }}
            installer/${{ steps.meta.outputs.installer }}.sha256
            release-manifest.json
          if-no-files-found: error

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.tag }}
          generate_release_notes: true
          prerelease: ${{ contains(steps.meta.outputs.tag, '-') }}
          files: |
            installer/${{ steps.meta.outputs.installer }}
            installer/${{ steps.meta.outputs.installer }}.sha256
            release-manifest.json
          fail_on_unmatched_files: true

      - name: Release Summary
        shell: pwsh
        run: |
          @"
          Release published for tag: ${{ steps.meta.outputs.tag }}
          Installer: ${{ steps.meta.outputs.installer }}
          Manifest asset URL (latest release):
          https://github.com/${{ github.repository }}/releases/latest/download/release-manifest.json
          "@ | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
